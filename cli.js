#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const inquirer = require('inquirer');
const chalk = require('chalk');

class ComponentBuilder {
    constructor() {
        this.componentsDir = path.join(process.cwd(), 'components');
        this.distDir = path.join(process.cwd(), 'dist');
        this.configPath = path.join(process.cwd(), 'config.json');
        this.components = [];
        this.config = this.loadConfig();
    }

    // Konfiguration laden
    loadConfig() {
        try {
            if (fs.existsSync(this.configPath)) {
                const configData = fs.readFileSync(this.configPath, 'utf8');
                return JSON.parse(configData);
            }
        } catch (error) {
            console.log('‚ö†Ô∏è  Fehler beim Laden der Konfiguration, verwende Standardwerte');
        }
        
        // Fallback zu Standardkonfiguration
        return {
            ui: {
                colors: {
                    confirm: "#00ff00",
                    cancel: "#ff0000", 
                    selected: "#00bcd4",
                    unselected: "#666666"
                },
                typeColors: {
                    html: "#e34c26",
                    css: "#1572b6",
                    js: "#f7df1e",
                    javascript: "#f7df1e",
                    default: "#ffffff"
                }
            }
        };
    }

    // Farbe f√ºr Typ abrufen
    getTypeColor(type) {
        const typeColorMap = {
            html: 'red',
            css: 'blue', 
            js: 'yellow',
            javascript: 'yellow',
            typescript: 'cyan',
            json: 'gray',
            xml: 'magenta',
            php: 'magenta',
            python: 'green',
            java: 'yellow',
            go: 'cyan',
            rust: 'gray',
            c: 'gray',
            cpp: 'blue',
            default: 'white'
        };
        
        return typeColorMap[type.toLowerCase()] || typeColorMap.default;
    }

    // Farbiges Terminal-Text erstellen mit chalk
    colorText(text, colorName) {
        switch(colorName) {
            case 'red': return chalk.red(text);
            case 'blue': return chalk.blue(text);
            case 'yellow': return chalk.yellow(text);
            case 'green': return chalk.green(text);
            case 'cyan': return chalk.cyan(text);
            case 'magenta': return chalk.magenta(text);
            case 'gray': return chalk.gray(text);
            case 'white': return chalk.white(text);
            case 'confirm': return chalk.green(text);
            case 'cancel': return chalk.red(text);
            case 'selected': return chalk.cyan(text);
            default: return text;
        }
    }

    // Alle JSON-Komponenten laden
    loadComponents() {
        try {
            if (!fs.existsSync(this.componentsDir)) {
                console.log('‚ùå components/ Ordner nicht gefunden!');
                return false;
            }

            const files = fs.readdirSync(this.componentsDir)
                .filter(file => file.endsWith('.json'));

            if (files.length === 0) {
                console.log('‚ùå Keine JSON-Komponenten gefunden!');
                return false;
            }

            this.components = files.map(file => {
                const filePath = path.join(this.componentsDir, file);
                const content = JSON.parse(fs.readFileSync(filePath, 'utf8'));
                return {
                    ...content,
                    filename: file
                };
            });

            return true;
        } catch (error) {
            console.log('‚ùå Fehler beim Laden der Komponenten:', error.message);
            return false;
        }
    }

    // Verf√ºgbare Typen ermitteln
    getAvailableTypes() {
        const types = [...new Set(this.components.map(comp => comp.type))];
        return types.sort();
    }

    // Verf√ºgbare Gruppen f√ºr ausgew√§hlte Typen ermitteln
    getAvailableGroups(selectedTypes) {
        const groups = new Set();
        
        this.components
            .filter(comp => selectedTypes.includes(comp.type))
            .forEach(comp => {
                if (comp.group) {
                    groups.add(`${comp.type}:${comp.group}`);
                }
            });
        
        return Array.from(groups).map(groupKey => {
            const [type, group] = groupKey.split(':');
            return { type, group };
        });
    }

    // Komponenten nach Gruppen strukturieren
    getComponentsByGroup(selectedTypes, selectedGroups = null) {
        const structure = {};
        
        this.components
            .filter(comp => selectedTypes.includes(comp.type))
            .forEach(comp => {
                const type = comp.type;
                const group = comp.group || null;
                
                // Wenn Gruppen ausgew√§hlt wurden, nur diese ber√ºcksichtigen
                if (selectedGroups && group && !selectedGroups.some(g => g.type === type && g.group === group)) {
                    return;
                }
                
                if (!structure[type]) {
                    structure[type] = {};
                }
                
                if (group) {
                    if (!structure[type][group]) {
                        structure[type][group] = [];
                    }
                    structure[type][group].push(comp);
                } else {
                    if (!structure[type]['_ungrouped']) {
                        structure[type]['_ungrouped'] = [];
                    }
                    structure[type]['_ungrouped'].push(comp);
                }
            });
        
        return structure;
    }

    // Interaktive Komponentenauswahl mit Kategorien und optionalen Gruppen
    async selectComponents() {
        // Erste Auswahl: Kategorie (Typ) w√§hlen
        const types = this.getAvailableTypes();
        
        if (types.length === 0) {
            console.log('‚ùå Keine Komponenten verf√ºgbar');
            return [];
        }

        // Startup-Informationen anzeigen
        console.log(`üìä ${chalk.cyan(types.length)} Kategorien erkannt: ${types.map(t => this.colorText(t.toUpperCase(), this.getTypeColor(t))).join(', ')}`);
        console.log(`üì¶ ${chalk.cyan(this.components.length)} Komponenten insgesamt geladen`);
        
        // Steuerungs√ºbersicht anzeigen
        console.log(`\n${chalk.gray('‚îå‚îÄ Steuerung ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê')}`);
        console.log(`${chalk.gray('‚îÇ')} ${chalk.cyan('Space')} - Element ausw√§hlen/abw√§hlen          ${chalk.gray('‚îÇ')}`);
        console.log(`${chalk.gray('‚îÇ')} ${chalk.green('Enter')} - Auswahl best√§tigen                  ${chalk.gray('‚îÇ')}`);
        console.log(`${chalk.gray('‚îÇ')} ${chalk.red('Ctrl+C')} - Programm beenden                  ${chalk.gray('‚îÇ')}`);
        console.log(`${chalk.gray('‚îÇ')} ${chalk.cyan('‚Üë‚Üì')}    - Navigation                          ${chalk.gray('‚îÇ')}`);
        console.log(`${chalk.gray('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò')}\n`);

        // Schritt 1: Kategorien ausw√§hlen
        let selectedTypes = types;
        if (types.length > 1) {
            const typeChoices = types.map(type => {
                const count = this.components.filter(c => c.type === type).length;
                const color = this.getTypeColor(type);
                return {
                    name: this.colorText(`${type.toUpperCase()}`, color) + ` (${count} Komponenten)`,
                    value: type
                };
            });

            const { types: selectedTypesResult } = await inquirer.prompt([{
                type: 'checkbox',
                name: 'types',
                message: 'Schritt 1/3: Welche Kategorien m√∂chtest du ausw√§hlen?',
                choices: typeChoices,
                default: types, // Alle standardm√§√üig ausgew√§hlt
                validate: (input) => {
                    return input.length > 0 ? true : 'Bitte w√§hle mindestens eine Kategorie aus.';
                }
            }]);

            selectedTypes = selectedTypesResult;
        }

        // Schritt 2: Gruppen ausw√§hlen (falls vorhanden)
        const availableGroups = this.getAvailableGroups(selectedTypes);
        let selectedGroups = null;

        if (availableGroups.length > 0) {
            console.log(`\n‚ú® ${chalk.cyan(availableGroups.length)} Gruppen gefunden`);
            
            const groupChoices = [
                {
                    name: chalk.white('‚úì Alle Gruppen einschlie√üen'),
                    value: 'all'
                },
                ...availableGroups.map(({ type, group }) => {
                    const typeColor = this.getTypeColor(type);
                    const componentsInGroup = this.components.filter(c => c.type === type && c.group === group).length;
                    return {
                        name: `${this.colorText(type.toUpperCase(), typeColor)} ‚Ä∫ ${chalk.white(group)} (${componentsInGroup} Komponenten)`,
                        value: { type, group }
                    };
                })
            ];

            const { groups } = await inquirer.prompt([{
                type: 'checkbox',
                name: 'groups',
                message: 'Schritt 2/3: Welche Gruppen m√∂chtest du einschlie√üen?',
                choices: groupChoices,
                default: ['all'], // Alle standardm√§√üig ausgew√§hlt
                validate: (input) => {
                    return input.length > 0 ? true : 'Bitte w√§hle mindestens eine Gruppe aus.';
                }
            }]);

            // Wenn "all" nicht ausgew√§hlt wurde, nur spezifische Gruppen verwenden
            if (!groups.includes('all')) {
                selectedGroups = groups.filter(g => g !== 'all');
            }
        }

        // Schritt 3: Komponenten mit robustem inquirer System ausw√§hlen
        return await this.selectComponentsWithInquirer(selectedTypes, selectedGroups);
    }

    // Robuste Komponentenauswahl mit inquirer
    async selectComponentsWithInquirer(selectedTypes, selectedGroups) {
        const componentStructure = this.getComponentsByGroup(selectedTypes, selectedGroups);
        const choices = [];
        const componentMap = new Map();
        const groupMap = new Map();

        // Choices f√ºr inquirer erstellen
        Object.entries(componentStructure).forEach(([type, groups]) => {
            const typeColor = this.getTypeColor(type);
            
            // Kategorie-Header (Sprache) - nur bei mehreren Sprachen
            if (selectedTypes.length > 1) {
                choices.push(new inquirer.Separator(`\n${this.colorText(`‚îÄ‚îÄ ${type.toUpperCase()} ‚îÄ‚îÄ`, typeColor)}`));
            }

            Object.entries(groups).forEach(([groupName, components]) => {
                // Gruppen-Header f√ºr echte Gruppen
                if (groupName !== '_ungrouped') {
                    const groupKey = `group_${type}_${groupName}`;
                    groupMap.set(groupKey, components);
                    
                    choices.push({
                        name: `${this.colorText(`üìÅ ${groupName.toUpperCase()}`, typeColor)} ${chalk.gray(`(${components.length} Komponenten)`)}`,
                        value: groupKey,
                        short: `Gruppe: ${groupName}`
                    });
                }

                // Komponenten hinzuf√ºgen
                components.forEach((comp, index) => {
                    const isGrouped = groupName !== '_ungrouped';
                    const prefix = isGrouped ? '  ' : '';
                    const bullet = this.colorText('‚Ä¢', typeColor);
                    
                    const compKey = `comp_${type}_${groupName}_${index}`;
                    componentMap.set(compKey, comp);
                    
                    choices.push({
                        name: `${prefix}${bullet} ${comp.title} - ${chalk.gray(comp.description)}`,
                        value: compKey,
                        short: comp.title
                    });
                });
            });
        });

        // Inquirer Prompt f√ºr Komponentenauswahl
        const { selectedItems } = await inquirer.prompt([{
            type: 'checkbox',
            name: 'selectedItems',
            message: 'Schritt 3/3: Welche Komponenten m√∂chtest du verwenden?',
            choices: choices,
            pageSize: 15, // Mehr Items pro Seite anzeigen
            validate: (input) => {
                return input.length > 0 ? true : 'Bitte w√§hle mindestens eine Komponente oder Gruppe aus.';
            }
        }]);

        // Ausgew√§hlte Items verarbeiten
        const finalComponents = [];
        let componentIndex = 0; // Eindeutiger Index f√ºr jede Komponente

        selectedItems.forEach(itemKey => {
            if (itemKey.startsWith('group_')) {
                // Gruppe ausgew√§hlt - alle Komponenten hinzuf√ºgen
                const components = groupMap.get(itemKey);
                if (components) {
                    components.forEach(comp => {
                        // Jede Komponente bekommt einen eindeutigen Index
                        finalComponents.push({
                            ...comp,
                            _uniqueId: componentIndex++
                        });
                    });
                    console.log(`‚úÖ Gruppe ausgew√§hlt: ${chalk.green(components.length)} Komponenten hinzugef√ºgt`);
                }
            } else if (itemKey.startsWith('comp_')) {
                // Einzelne Komponente ausgew√§hlt
                const comp = componentMap.get(itemKey);
                if (comp) {
                    // Jede Komponente bekommt einen eindeutigen Index
                    finalComponents.push({
                        ...comp,
                        _uniqueId: componentIndex++
                    });
                }
            }
        });

        console.log(`\nüéâ ${chalk.green(finalComponents.length)} Komponenten insgesamt ausgew√§hlt`);
        return finalComponents;
    }

    // Bundle-Option abfragen
    async askForBundle() {
        const { bundle } = await inquirer.prompt([{
            type: 'confirm',
            name: 'bundle',
            message: 'M√∂chtest du die Dateien nach Typ b√ºndeln?',
            default: false
        }]);

        return bundle;
    }

    // Dateien generieren
    generateFiles(selectedComponents, bundle = false) {
        // Dist-Ordner erstellen falls nicht vorhanden
        if (!fs.existsSync(this.distDir)) {
            fs.mkdirSync(this.distDir);
        }

        if (bundle) {
            this.generateBundledFiles(selectedComponents);
        } else {
            this.generateSeparateFiles(selectedComponents);
        }
    }

    // Separate Dateien erstellen
    generateSeparateFiles(components) {
        const generatedFiles = [];

        components.forEach(comp => {
            // Eindeutigen Dateinamen erstellen (mit Index falls identische Titel)
            const uniqueFileName = comp._uniqueId !== undefined 
                ? `${comp.title.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase()}-${comp._uniqueId}.${comp.type}`
                : this.generateFileName(comp.title, comp.type);
                
            const filePath = path.join(this.distDir, uniqueFileName);
            
            fs.writeFileSync(filePath, comp.content, 'utf8');
            generatedFiles.push(uniqueFileName);
        });

        console.log('\n‚úÖ Separate Dateien erstellt:');
        generatedFiles.forEach(file => console.log(`   üìÑ ${file}`));
    }

    // Geb√ºndelte Dateien erstellen
    generateBundledFiles(components) {
        const typeGroups = {};
        
        // Nach Typ gruppieren
        components.forEach(comp => {
            if (!typeGroups[comp.type]) {
                typeGroups[comp.type] = [];
            }
            typeGroups[comp.type].push(comp);
        });

        const generatedFiles = [];

        // F√ºr jeden Typ eine Datei erstellen
        Object.entries(typeGroups).forEach(([type, comps]) => {
            const fileName = `bundle.${type}`;
            const filePath = path.join(this.distDir, fileName);
            
            // Inhalte kombinieren mit Kommentaren (auch identische Komponenten)
            const bundledContent = comps.map(comp => 
                `/* ${comp.title} - ${comp.description} ${comp._uniqueId !== undefined ? `(ID: ${comp._uniqueId})` : ''} */\n${comp.content}`
            ).join('\n\n');
            
            fs.writeFileSync(filePath, bundledContent, 'utf8');
            generatedFiles.push(fileName);
        });

        console.log('\n‚úÖ Geb√ºndelte Dateien erstellt:');
        generatedFiles.forEach(file => console.log(`   üì¶ ${file}`));
    }

    // Dateiname generieren
    generateFileName(title, type) {
        const sanitized = title.toLowerCase()
            .replace(/[^a-z0-9\s-]/g, '')
            .replace(/\s+/g, '-')
            .replace(/-+/g, '-')
            .trim('-');
        return `${sanitized}.${type}`;
    }

    // Verf√ºgbare Komponenten auflisten
    listComponents() {
        if (!this.loadComponents()) return;

        console.log('\nüìã Verf√ºgbare Komponenten:');
        console.log('=' .repeat(50));

        const types = this.getAvailableTypes();
        types.forEach(type => {
            const typeColor = this.getTypeColor(type);
            console.log(`\nüè∑Ô∏è  ${this.colorText(type.toUpperCase(), typeColor)}`);
            
            const compsOfType = this.components.filter(comp => comp.type === type);
            
            // Nach Gruppen organisieren
            const grouped = {};
            compsOfType.forEach(comp => {
                const group = comp.group || '_ungrouped';
                if (!grouped[group]) grouped[group] = [];
                grouped[group].push(comp);
            });

            Object.entries(grouped).forEach(([groupName, components]) => {
                if (groupName !== '_ungrouped') {
                    console.log(`   ${chalk.gray('‚îî‚îÄ')} ${chalk.white(groupName)}`);
                }
                
                components.forEach(comp => {
                    const prefix = groupName !== '_ungrouped' ? '     ' : '   ';
                    console.log(`${prefix}${this.colorText('‚Ä¢', typeColor)} ${comp.title}`);
                    console.log(`${prefix}  ${chalk.gray(comp.description)}`);
                });
            });
        });

        console.log(`\nüìä Gesamt: ${chalk.cyan(this.components.length.toString())} Komponenten in ${chalk.cyan(types.length.toString())} Kategorien`);
        
        // Gruppenz√§hlung
        const totalGroups = new Set();
        this.components.forEach(comp => {
            if (comp.group) totalGroups.add(`${comp.type}:${comp.group}`);
        });
        
        if (totalGroups.size > 0) {
            console.log(`üóÇÔ∏è  ${chalk.cyan(totalGroups.size.toString())} Gruppen verf√ºgbar`);
        }
        
        // Konfigurationshilfe
        console.log(`\n‚öôÔ∏è  Konfiguration: ${chalk.cyan('config.json')} bearbeiten um Farben anzupassen`);
    }

    // Beispielkomponenten erstellen
    initProject() {
        console.log('üöÄ Initialisiere Projekt...');
        
        // Components-Ordner erstellen
        if (!fs.existsSync(this.componentsDir)) {
            fs.mkdirSync(this.componentsDir);
            console.log('‚úÖ components/ Ordner erstellt');
        }

        // Dist-Ordner erstellen
        if (!fs.existsSync(this.distDir)) {
            fs.mkdirSync(this.distDir);
            console.log('‚úÖ dist/ Ordner erstellt');
        }

        console.log('‚úÖ Projekt initialisiert! Beispielkomponenten sind bereits vorhanden.');
        console.log('\nüéØ N√§chste Schritte:');
        console.log('   npm install');
        console.log('   npm start');
        console.log(`\n‚öôÔ∏è  Tipp: Bearbeite ${chalk.cyan('config.json')} um Farben und Steuerung anzupassen`);
    }

    // ASCII Art anzeigen
    showBanner() {
        console.log(chalk.cyan(`
  __    __                  __            __    __          ______   __        ______ 
/  |  /  |                /  |          /  |  /  |        /      \\ /  |      /      |
$$ | /$$/   ______    ____$$ |  ______  $$ |  $$ |       /$$$$$$  |$$ |      $$$$$$/ 
$$ |/$$/   /      \\  /    $$ | /      \\ $$  \\/$$/ ______ $$ |  $$/ $$ |        $$ |  
$$  $$<   /$$$$$$  |/$$$$$$$ |/$$$$$$  | $$  $$< /      |$$ |      $$ |        $$ |  
$$$$$  \\  $$ |  $$ |$$ |  $$ |$$    $$ |  $$$$  \\$$$$$$/ $$ |   __ $$ |        $$ |  
$$ |$$  \\ $$ \\__$$ |$$ \\__$$ |$$$$$$$$/  $$ /$$  |       $$ \\__/  |$$ |_____  _$$ |_ 
$$ | $$  |$$    $$/ $$    $$ |$$       |$$ |  $$ |       $$    $$/ $$       |/ $$   |
$$/   $$/  $$$$$$/   $$$$$$$/  $$$$$$$/ $$/   $$/         $$$$$$/  $$$$$$$$/ $$$$$$/ 
        `));
        console.log(chalk.gray('               Your Private Component Libary Bundler'));
        console.log(chalk.gray('                      Created by @knutpfr'));
        console.log(chalk.gray('               https://github.com/knutpfr/KodeX-CLI\n'));
    }

    // Hauptfunktion
    async run() {
        const args = process.argv.slice(2);
        const command = args[0] || 'build';

        // Banner nur bei 'start' oder 'build' anzeigen
        if (command === 'build' || args.length === 0) {
            this.showBanner();
        } else {
            console.log(chalk.cyan('üîß CLI Component Builder'));
            console.log('=' .repeat(30));
        }

        switch (command) {
            case 'init':
                this.initProject();
                break;
            
            case 'list':
                this.listComponents();
                break;
            
            case 'config':
                console.log(`\n‚öôÔ∏è  Konfigurationsdatei: ${chalk.cyan('config.json')}`);
                console.log('\nüìù Verf√ºgbare Einstellungen:');
                console.log('   ‚Ä¢ ui.typeColors - Farben f√ºr verschiedene Dateitypen');
                console.log('   ‚Ä¢ ui.colors - Allgemeine UI-Farben');
                console.log('   ‚Ä¢ output - Ausgabeeinstellungen');
                break;
            
            case 'build':
            default:
                if (!this.loadComponents()) return;

                const selected = await this.selectComponents();
                if (selected.length === 0) {
                    console.log('\n‚ùå Keine Komponenten ausgew√§hlt');
                    return;
                }

                const bundle = await this.askForBundle();
                this.generateFiles(selected, bundle);

                console.log(`\nüéâ ${chalk.green(selected.length.toString())} Komponenten erfolgreich generiert!`);
                console.log(`üìÅ Dateien befinden sich in: ${chalk.cyan(this.distDir)}`);
                break;
        }
    }
}

// CLI ausf√ºhren
if (require.main === module) {
    const builder = new ComponentBuilder();
    builder.run().catch(error => {
        console.error('‚ùå Fehler:', error.message);
        process.exit(1);
    });
}

module.exports = ComponentBuilder;